/** Graphics library of JS: three.js, paper.js, Fabric.js */
var activeTouches=[];
 //event.sourceCapabilities.firesTouchEvents not available in Mozilla
 var ctxColor = 'black';			// used by turtle color 
 var ctxFillStyle = 'red';			//used in fill a shape on canvas
 var ctxStrick = 2;
 var globalShape = "freeHand";
 var globalCanvas;
 var globalContext;
 
function startup() {
  globalCanvas = document.getElementById("IDcanvas");
  globalContext = globalCanvas.getContext("2d");
globalContext.lineCap = "round";

  globalCanvas.addEventListener("touchstart", onTouch, false);
  globalCanvas.addEventListener("touchend",	  onTouch, false);
  globalCanvas.addEventListener("touchcancel",onTouch, false);
  globalCanvas.addEventListener("touchmove",  onTouch, false);
 
  globalCanvas.addEventListener("mousedown", 	onMouse, false);
//  globalCanvas.addEventListener("mousemove", 	onMouse, false);  if we attached mouseMove at document load, every time it will capture mouseMove event on canvas, so capture mouseMove only after mouseDown
  globalCanvas.addEventListener("mouseup", 		onMouse, false);

  // For Testing purpose
  globalCanvas.addEventListener("mousemove", showCoordinates, false);
}
// This sets up all the event listeners for our <canvas> element so we can handle the touch events as they occur.
document.addEventListener("DOMContentLoaded", startup);


 /**
 ####################################################################################################################
 #		Touch, Click and Remote event managing section																#
 ####################################################################################################################
*/
/* This convert Touch and click Coordinates according to canvas Coordinates on the screen */
 function getCanvasCoordinates(event) {
 var x = event.clientX - globalCanvas.getBoundingClientRect().left, 
	 y = event.clientY - globalCanvas.getBoundingClientRect().top;

    return {x: x, y: y};
}
/* When this variable is true it'll enable mouse event on touch screen also */
var isMouseEventRequired = true; //Testing purpose only enable for showing position mouse corresponding to the touch other wise make it false
function onTouch(Touchevt){
	Touchevt.preventDefault();
	
	var position = getCanvasCoordinates(Touchevt.changedTouches[0]);
	var touch = {	"identifier":Touchevt.changedTouches[0].identifier, 
					"shape":globalShape,
					"pageX":position.x, 
					"pageY":position.y
				};
				
	switch(Touchevt.type){
	    case "touchstart":
			tools = {"color":ctxColor, "fillColor":ctxFillStyle, "lineWidth":ctxStrick };
			touch.tools=tools;
			touch.action = "start";
			
			drawing(touch,"touchID");
			if(sess != undefined)
				publishOnRemote(touch,"remoteStart");			
        break;
		case "touchmove":
			touch.action = "move";
			
			drawing(touch,"touchID");
			if(sess != undefined)
				publishOnRemote(touch,"remoteMove");			
        break;
		case "touchend":
			touch.action = "end";
			
			drawing(touch,"touchID");
			if(sess != undefined)
				publishOnRemote(touch,"remoteEnd");			
        break;
		case "touchcancel":
			touch.action = "cancle";
			
			drawing(touch,"touchID");
			if(sess != undefined)
				publishOnRemote(touch,"remoteCancle");			
        break;		
	}
	
/* Convert TouchEvent into mouse click event for third party Framework */
if(isMouseEventRequired)
	onInterchange(Touchevt);
}

var isClicked = false;
function onMouse(evt) {
	/** Returns if mouseEvent is generated by ToucgEvent conversion, because there is no need of mouse event on Touch screen.
		This will allow only trusted moues event means that is only created by that device mouse*/
	if(evt.isTrusted != true)	
		return;
	
  evt.preventDefault();
  var position = getCanvasCoordinates(evt);
  
	var touch = {	"identifier":0, 
					"shape":globalShape,
					"pageX":position.x, 
					"pageY":position.y
				};

  switch (evt.type) {
    case "mousedown": 
		if(isClicked == false){
			tools = {"color":ctxColor, "fillColor":ctxFillStyle, "lineWidth":ctxStrick };
			touch.tools=tools;
			touch.action = "start";
			
			drawing(touch,"clickID");
			if(sess != undefined)
				publishOnRemote(touch,"remoteStart");	
			
			/** Only capture mousemove event when the mouseDown has occurs and remove on second mouseUp, that's by adding mousemove event here.*/
			globalCanvas.addEventListener("mousemove", onMouse, false);
			globalCanvas.style.cursor = "crosshair";
			isClicked = true;		
		}else {
			/** This 'else part' enable mouse pointer as a drawing pen until second click */
			isClicked = false;
		}
      break;
	  
    case "mousemove":
		if(isClicked == true){
			touch.action = "move";
			
			drawing(touch,"clickID");
	  	if(sess != undefined)
			publishOnRemote(touch,"remoteMove");				
		}
      break;
	  
    case "mouseup":
	/** On first click don't run mousUp event that's by pointer is able to continue drawing pen until second click. 
		if you don't want this feature then change if() with 'true' and uncomment isClicked=false here */
		if(isClicked == false){
			touch.action = "end";
			
			drawing(touch,"clickID");
			if(sess != undefined)
				publishOnRemote(touch,"remoteEnd");	
			
		//	isClicked=false;	
			globalCanvas.removeEventListener('mousemove', onMouse);
			globalCanvas.style.cursor = "default";
		}
      break;
	  
	case "mouseleave":		//This is not occurs in mouse event, That's by some time end stroke change the normal behaviour. Bug
			touch.action = "cancel";
			drawing(touch,"clickID"); console.log("mouse leave");
			if(sess != undefined)
				publishOnRemote(touch,"remoteCancle");			
      break;	  
  }

 }

 
 
var TouchPoint = function(){
	var identifier = null;
	var shape = null;
	var action = null;
	var pageX = null;
	var pageY = null;
	var tools = null;
}
/*
var touchList = function(){
	var TouchList = new Array();
	TouchList[0]=undefined;
	TouchList["length"]=0;
}
*/
function makeTouches(data){
 
	var	 touch = new TouchPoint();
	 touch.identifier = data.identifier;
	 touch.shape = data.shape;
	 touch.action = data.action;
	 touch.pageX = data.pageX;
	 touch.pageY = data.pageY;
	 touch.tools = data.tools;
/*	 
	var TouchList = new touchList();
	 TouchList[0]=touch;
	 TouchList["length"] = 1;
*/
	return touch;
	//	event.remote={"TouchList":{"0":Touch,"Length":1}};// this is read-only property of touch event so we can't change after creation,
	//	That's by we have to create other one similar to this ans assign that in touch event.
}

function onRemoteTouchEvent(arg1, touchData, arg3){
	var touch = makeTouches(touchData); 
/*	Deprecated section because start, move, end and cancel record is coming as 'action' data in 
	try{
		if(touchData.eventType === "remoteStart"){
			drawing(touch, touchData.remoteID);
			
		}else if(touchData.eventType === "remoteMove"){
			drawing(touch, touchData.remoteID);
			
		}else if(touchData.eventType === "remoteEnd"){
			drawing(touch,touchData.remoteID);
			
		}else if(touchData.eventType === "remoteCancle"){
			drawing(touch,touchData.remoteID);
		}
	}catch(e){console.log(e);}
*/
	drawing(touch,touchData.remoteID);
}

 /**
 ####################################################################################################################
 #		Handling Drawing Section																					#
 ####################################################################################################################
 Data Structure of Touches deprecated
 touchList:{"0": touch{"identifier":value, "pageX":value, "pageY":value, "color":value, "lineWidth":value, "fillcolor":value},
		    "length":1,
		    "remoteSession":
		}
	Now handle with this data	
 touch:{"0": touch{"identifier":value, "shape":value, "pageX":value, "pageY":value, "tools":{"color":value, "lineWidth":value, "fillcolor":value}}
 
 */

/** return previous point index according to current point's identifier */
function ongoingTouchIndexById(idToFind, index) {
	var currentScreen = activeTouches[index];
	
  for (var i = 1; i < currentScreen.length && currentScreen[i] != undefined ; i++) {
    var id = currentScreen[i].identifier;
    if (id == idToFind) {
      return i;
    }
  }
  return -1;   // It means there is no any point of current touch identifier
}

 /* This call method is not supported on Android 4, 
function copyTouch({ identifier, pageX, pageY }) {
  return { identifier, pageX, pageY };
}*/

/** copy tools from previous point into current point */
function copyTouch(point, index) {
	var ppi = ongoingTouchIndexById(point.identifier, index);  //ppi: previous point index 
	
	var screen = activeTouches[index];
	point.tools=screen[ppi].tools;
	return point;
}

/** It will return unique screen from activeTouches */
function checkPoint(deviceID){
	/*  This if() handle the situation in which touches are occur automatically like in broken screen touch some touch event occurs randomly   */
	if(deviceID === undefined || deviceID === null)
		return;
	var i;
	for( i=0; i<activeTouches.length; i++){			
		if(activeTouches[i][0] == deviceID)
			return i;
	}
	activeTouches[i]=[];
	activeTouches[i][0]=deviceID;
	return i;	
}


 function drawing(Touchpoint,id){
	 var isUndo = false;
	 var index = checkPoint(id);
	 var currentScreen = activeTouches[index];
	  
	 var ppi = ongoingTouchIndexById(Touchpoint.identifier, index);
	
	if(Touchpoint.action == "start" && ppi == -1){
		 currentScreen.push(Touchpoint);
		 points(Touchpoint);
	 }
	
	 if(Touchpoint.action == "move"){
		switch(Touchpoint.shape){
		 case "freeHand":
			 	freeHand(copyTouch(Touchpoint, index),index, ppi);	
			break;
		 case "line":

			break;
		case "rectangle":

			break
		case "circle":

			break;
		}
		
		 currentScreen.splice(ppi, 1, copyTouch(Touchpoint, index)); 	//move
	 }
	 
	 if(Touchpoint.action == "end"){
		var point = copyTouch(Touchpoint, index)
		points(point);
		currentScreen.splice(ppi, 1); 								
	 }
 }


 /**
 ####################################################################################################################
 #		Drawing Components																							#
 ####################################################################################################################
 */
 /*
 @param point current active point
 @param index active screen index from activeTouches
 @param idx   identifier index of touch point 
 */
function freeHand(point, index, idx){
	var currentScreen = activeTouches[index];
	
	  globalContext.strokeStyle =  point.tools.color || ctxColor;
	  globalContext.fillStyle  = point.tools.fillColor || ctxFillStyle;
	  globalContext.lineWidth = point.tools.lineWidth || ctxStrick;
	  
	  globalContext.beginPath();
      globalContext.moveTo(currentScreen[idx].pageX, currentScreen[idx].pageY);	
      globalContext.lineTo(point.pageX, point.pageY);	
	  globalContext.stroke();  
}

function line(){
	
}
function circle(){
	
}
function rectangle(){
	
}

 function points(cpoint){
	 globalContext.strokeStyle =  cpoint.tools.color || ctxColor;
	  globalContext.fillStyle  = cpoint.tools.fillColor || ctxFillStyle;
	  globalContext.lineWidth = cpoint.tools.lineWidth || ctxStrick;
	  
	 if(cpoint.action == "start"){
 		    globalContext.beginPath();
			globalContext.arc(cpoint.pageX, cpoint.pageY, 15, 0, 2 * Math.PI, false);
			globalContext.fill();
			globalContext.closePath();
	 }
	else if(cpoint.action =='end'){
		globalContext.beginPath();
		globalContext.lineTo(cpoint.pageX, cpoint.pageY);
		globalContext.fillRect(cpoint.pageX - 4, cpoint.pageY - 4, 8, 8);
		
	}	 
 }
 






















 /**
 ####################################################################################################################
 #		Various Tools For Painting																					#
 ####################################################################################################################
 */


function showCoordinates(evt){
/* Coordinates with mouse Event: 	(clientX , clientY)
									(layerX , layerY)
									(movementX , movementY)
									(offSetX , offSetY)
									(pageX , pageY)
									(screeX , screeY)
									(x , y)
									
				with touch Event:	(clientX , clientY)
									(pageX , pageY)
									(radiusX , radiusY)
									(screeX , screeY)
*/
									
	$(".coodinate").text("x:"+evt.layerX +", y:"+evt.layerY);
}
$(".shape").click(function(event) { 
	globalShape = event.target.value || globalShape;
});
$(".brushes").click(function(event) {
	ctxStrick = event.target.value || ctxStrick;
});
$(".colors").click(function(event) {// direct choose color 
	ctxColor = event.target.value || ctxColor;
});

$(".pick").change(function(event) { 
	ctxColor = event.target.value || ctxColor;
});
$(".fill").change(function(event) { 
	ctxFillStyle = event.target.value || ctxFillStyle;
});

$("#clrButton").click(function() {
	globalContext.clearRect(0, 0, globalCanvas.width, globalCanvas.height);
}); 
$("#eraserButton").click(function() {
	ctxStrick = 5;
	ctxColor = 'white';

}); 
$("#saveButton").click(function() {
	var imageName = prompt('Please enter image name');
    var canvasDataURL = golbalCanvas.toDataURL();
    var a = document.createElement('a');
    a.href = canvasDataURL;
    a.download = imageName || 'drawing';
    a.click();
});





/* Generate and return RGB color on a Integer */
function colorForTouch(nob) {
  var r = nob % 16;
  var g = Math.floor(nob / 3) % 16;
  var b = Math.floor(nob / 7) % 16;
  r = r.toString(16); // make it a hex digit
  g = g.toString(16); // make it a hex digit
  b = b.toString(16); // make it a hex digit
  var color = "#" + r + g + b;
//  console.log("color for touch with identifier: " + touch.identifier + ", Color: " + color);
  return color;
}



function log(msg) {
  var p = document.getElementById('log');
  p.innerHTML = msg + "\n" + p.innerHTML;
}







/*
Handling clicks
Since calling preventDefault() on a touchstart or the first touchmove event of a series 
 prevents the corresponding mouse events from firing, it's common to call preventDefault() 
 on touchmove rather than touchstart. That way, mouse events can still fire and things like
 links will continue to work. 
	Alternatively, some frameworks have taken to refiring touch 
 events as mouse events for this same purpose. (This example is oversimplified and may result 
 in strange behaviour. It is only intended as a guide.)

*/
/** Convert touch event in mouse event for those frameworks who's using mouse events only 
	and also prevent multiples move on series
*/
function onInterchange(evt) { 

  evt.preventDefault();
  if (evt.touches.length > 1 || (evt.type == "touchend" && evt.touches.length > 0)){ 
	// There should not conversion of more than 1 touch into mouseEvent 
		log("There is no any touch OR more then 1 touch, So no conversion into corresponding mouse event");
	return;
  }
  
  var newEvt = document.createEvent("MouseEvents");
  var type = null;
  var touch = null;

  switch (evt.type) {
    case "touchstart":
      type = "mousedown";
      touch = evt.changedTouches[0];
      break;
    case "touchmove":
      type = "mousemove";
      touch = evt.changedTouches[0];
      break;
    case "touchend":
      type = "mouseup";
      touch = evt.changedTouches[0];
      break;
  }
  
  newEvt.initMouseEvent(type, true, true, evt.target.ownerDocument.defaultView, 0,
    touch.screenX, touch.screenY, touch.clientX, touch.clientY,
    evt.ctrlKey, evt.altKey, evt.shiftKey, evt.metaKey, 0, null);
	
  evt.target.dispatchEvent(newEvt);
  console.log(" Touch converted into Click");

  /*
  Calling preventDefault() only on a second touch
One technique for preventing things like pinchZoom on a page is to call preventDefault() on the second touch in a series. This behavior is not well defined in the touch events spec and results in different behavior for different browsers (i.e., iOS will prevent zooming but still allow panning with both fingers; Android will allow zooming but not panning; Opera and Firefox currently prevent all panning and zooming.) Currently, it's not recommended to depend on any particular behavior in this case, but rather to depend on meta viewport to prevent zooming.
  */
}






